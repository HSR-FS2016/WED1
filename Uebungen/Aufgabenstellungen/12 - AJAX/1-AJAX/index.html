<!doctype html>
<html lang="de">
	<head>
		<meta charset="utf-8" />
		<title>WED1 - AJAX &amp; Template Engine: Übung 1 AJAX</title>
		<link rel="icon" href="../HSR.Template.Exercises/icon-document.png" type="image/png">

		<link rel="stylesheet" type="text/css" href="../HSR.Template.Exercises/documentStyle.css">
		<script src="../HSR.Template.Exercises/solutions.js"></script>
		<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

		<style>
			.important-code {
			 font-size: 1.25em; padding: 0.5em 0; display: inline-block; background: white;
			}
		</style>
	</head>
	<body>
		<h1>
			<a class="backlink" href="../index.html">⇦</a>
			WED1 - AJAX &amp; Template Engine: Übung 1 AJAX
			<button id="showSolutions">Lösungen anzeigen/ausblenden</button>
		</h1>
		

		<h2>Installation &amp; Start des Node.js Servers</h2>
		<h3>Installation</h3>
		<ol>
			<li>Installieren Sie die neuste Version von <a href="https://nodejs.org/en/download/current/">Node.js</a>.</li>
			<li>Starten Sie Webstorm und öffnen Sie die Übung.</li>
			<li>Öffnen Sie das Terminal (Webstorm beinhaltet ein Terminal: Unten Links "Terminal" oder [View] >
			[Window Tools] > [Terminal]).</li>
			<li>Kontrollieren Sie, das sie die neuste Version von Node.js installieren haben.
				<pre class="prettyprint"><code class="language-javascript">node --version</code></pre>
			</li>
			<li>Navigieren Sie in den Ordner "server", wo sich die Datei "package.json" befindet.</li>
			<li>Installieren Sie die benötigten Abhänigkeiten:
				<pre class="prettyprint"><code class="language-javascript">npm install</code></pre>
				NPM wird automatisch alle in "package.json" aufgelisteten Dependencies installieren im Ordner
				"node_modules".
			</li>
		</ol>

		<h3>Starten</h3>
		<ol>
			<li>"server.js" ausführen:
				<ul>
					<li>Entweder mittels Webstorm: Rechtsklick auf "server.js" &rarr; [Run server.js]</li>
					<li>Oder im Terminal: <pre
					class="prettyprint"><code class="language-javascript">npm start</code></pre>
					</li>
				</ul>
				&#10145; Dies startet nun das in "package.json" angegebene main-script (server.js).
			</li>
			<li>Der Server läuft nun unter der in der Konsole angegebenen Url. Sie sollten den Titel "Current time" und
			einen Button im Browser angezeigt erhalten.</li>
		</ol>

		<h3>Stoppen</h3>
		<ul>
			<li>WS: Auf den roten viereckigen Stoppknopf drücken</li>
			<li>Terminal: Ctrl+C drücken</li>
		</ul>



		<h2>Theorie</h2>
		<ul>
			<li>Die XMLHttpRequest Syntax ist im <a href="https://developer.mozilla.org/de/docs/Web/API/XMLHttpRequest" target="_blank">Mozilla Developer Network</a> ausführlich beschrieben.</li>
			<li>Das Objekt XMLHttpRequest wurde unter <a href="http://www.w3.org/TR/XMLHttpRequest/" target="_blank">W3.org</a> standardisiert.</li>
		</ul>



		<h2>AJAX Grundlagen</h2>
		<p>
			Wikipedia.de beschreibt AJAX (Asynchronous JavaScript and XML) mit XMLHttpRequest wie folgt:
			<br />
			<i>
				XMLHttpRequest (XHR) ist eine Programmierschnittstelle für JavaScript zum Übertragen von Daten über das HTTP-Protokoll.
				XMLHttpRequest bildet einen Grundbaustein der Ajax-Technik. XMLHttpRequest ermöglicht es einem Skript einer Webseite, Daten dynamisch vom
				Webserver abzurufen, ohne dass dazu die HTML-Seite neu geladen werden müsste. Dies war zuvor nur durch den Einsatz unsichtbarer HTML-Frames oder IFrames oder mit dynamisch nachgeladenen Skript-Dateien möglich.
				Da beim XMLHttpRequest-Verfahren Daten asynchron verarbeitet werden können, muss ein Skript nicht warten, bis die Anfrage beantwortet ist, sondern kann sich solange anderen Aufgaben zuwenden.
			</i>
		</p>
		<p>
			Studieren Sie das folgende Code-Schnippsel und schauen Sie sich <a
			href="./server/app/index.html" target="_blank" download>server/app/index.html</a> an.
			<figure>
				<pre class="prettyprint"><code class="language-javascript"><!--
-->function getTime(onTimeAvaiable, onTimeError) {
	if (typeof(onTimeAvaiable) !== 'function') {
		throw "'onTimeAvaiable' must be a function";
	}
	if (typeof(onTimeError) !== 'function') {
		throw "'onTimeError' must be a function";
	}
	
	var client = new XMLHttpRequest();
	client.onreadystatechange = function() {
		if (client.readyState === 4) {
			if (client.status === 200) {
				onTimeAvaiable(JSON.parse(client.responseText));
			}
			else {
				onTimeError(client);
			}
		}
	};
	
	client.onerror = onTimeError;
	client.open('GET', '/time', true);
	client.send(null);
}<!--
			--></code></pre>
				<figcaption><a href="./server/app/loader.js" target="_blank">server/app/loader.js</a></figcaption>
			</figure>
		</p>
		<p>Beantworten Sie mit Hilfe des <a href="http://www.w3.org/TR/XMLHttpRequest/" target="_blank">Standards</a> die folgenden Fragen:
		<ol style="list-style-type: lower-alpha; ">
			<li>
				Der Code-Abschnitt oben verwendet den 'onreadystatechange'-Event sowie den <code>readyState</code> '4'.
				Was besagt der readyState in Zusammenhang mit dem <code>status</code> '200' aus?

				<div class="solution">
					<p>W3C schreibt dazu folgendes:</p>
					<ul>
						<li><strong>status</strong> Returns the HTTP status code.</li>
						<li><strong>readyState</strong> DONE (numeric value 4); The data transfer has been completed or something went wrong during the transfer (e.g. infinite redirects).</li>
					</ul>
				</div>
			</li>
			<li>
				Beschreiben Sie die Funktionalität der Methode open() in wenigen Worten.

				<div class="solution">
					<p>Open initialisiert eine neue Anfrage zu einem Server. Dabei wird die Web-Methode, die anzuwählende URL sowie die Asynchronität definiert. Mehr dazu unter <a href="https://developer.mozilla.org/de/docs/Web/API/XMLHttpRequest#open()" taget="_blank">XMLHttpRequest#open()</a>.</p>
				</div>
			</li>
			<li>
				Wie können Sie die Asynchronität des Requests beeinflussen?

				<div class="solution">
					<p>Die Methode <a href="https://developer.mozilla.org/de/docs/Web/API/XMLHttpRequest#open()" taget="_blank">XMLHttpRequest#open()</a> unterstützt asynchrone Aufrufe mittels des Arguments async=true.</p>
				</div>
			</li>
			<li>
				Würden Sie eher synchrone oder asynchrone Ausführung bevorzugen (mit Begründung)?

				<div class="solution">
					<p>Asynchrone Aufrufe sind vorzuziehen, weil synchrone Aufrufe den Browser solange
					blockieren, bis der Server die Antwort geliefert hat. Falls der Server nicht verfügbar ist,
					bleibt der Browser bis zu einem Timeout (konfigurierbar, bis zu 90s) blockiert.</p>
				</div>
			</li>
			<li>
				Wie können Sie einen spezifischen Content-Type vom Server anfordern?

				<div class="solution">
					<pre class="prettyprint"><code class="language-javascript">client.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");</code></pre>
				</div>
			</li>
			<li>
				Sie müssten die Client-Zeitzone dem Server als JSON im request body im Format <code>{zone:"+2"}</code> übergeben.
				Beschreiben Sie, wie Sie dies im Code oben integrieren würden.

				<div class="solution">
					<pre class="prettyprint"><code class="language-javascript"><!--
-->...
client.open('POST', '/time', true);
client.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
client.send(JSON.stringify({zone:"+2"}));<!--
					--></code></pre>
				</div>
			</li>
		</ol>



		<h2>AJAX mit jQuery</h2>
		<ol style="list-style-type: lower-alpha;">
			<li>
				Implementieren Sie die Function <code>getTime()</code> aus der ersten Aufgabe mit jQuery. Schreiben
				Sie dazu
				<a href="./server/app/loader.js" target="_blank">server/app/loader.js</a> um.
				Verwenden Sie die <a href="https://api.jquery.com/jquery.get/" target="_blank">$.get</a> Methode.
				Der Server liefert die Zeit als Text, z.B. <pre>Wed May 11 2016 16:56:56 GMT+0200 (CEST)</pre>.

				<div class="solution">
					<pre class="prettyprint"><code class="language-javascript"><!--
-->function getTime(onTimeAvailable, onTimeError) {
    if (typeof(onTimeAvailable) !== 'function') {
        throw "'onTimeAvaiable' must be a function";
    }
    if (typeof(onTimeError) !== 'function') {
        throw "'onTimeError' must be a function";
    }

    $.get('/time', onTimeAvailable).fail(onTimeError);
}<!--
					--></code></pre>
				</div>
			</li>
			<li>
				Machen Sie sich mit <a href="https://api.jquery.com/jquery.ajax/" target="_blank">$.ajax</a> vertraut.
				Ist es möglich, den $.get Befehl mit $.ajax zu ersetzen? Worin Besteht der Vorteil von $.ajax?

				<div class="solution">
					<p>Es können zusätzliche Einstellung am Web-Request vorgenommen werden, wie zum Beispiel
					Web-Methode wie PATCH, PUT, usw. </p>
					<pre class="prettyprint"><code class="language-javascript"><!--
-->function getTime(onTimeAvailable, onTimeError) {
    if (typeof(onTimeAvailable) !== 'function') {
        throw "'onTimeAvaiable' must be a function";
    }
    if (typeof(onTimeError) !== 'function') {
        throw "'onTimeError' must be a function";
    }

    $.ajax('/time', { method: 'GET', cache: false }).done(onTimeAvailable).fail(onTimeError);
}<!--
					--></code></pre>
					<p><code>cache: false</code> wird benötigt, da der Browser unter Umständen GET-Requests cached.</p>
				</div>
			</li>
			<li>Gibt es Unterschiede in den Requests bei der Verwendung von XMLHttpRequest / $.get() / $.ajax()
			(siehe Network Tab in den Developer Tools)?
				<div class="solution">
				<p>Die Requests sehen mehrheitlich gleich aus; falls der Cache unterdrückt wird, generiert jQuery ein
				 zusätliches Query-Argument in den Request. Der Browser-Cache erstellt nun für jeden Request einen
				 neuen Eintrag, da die Requests auf unterschiedliche URLs (/time?_=1428514925530) zeigen.</p>
				 </div>
			</li>
		</ol>


		<h2>AJAX & JSON</h2>
		<ol>
			<li>
				Bauen Sie die getTime()-Funktion um. Verwenden Sie $.getJSON() von jQuery. Der Server wird
				automatisch ein JSON zurückliefern, weil jQuery den Accept-Header "application/json" mitschickt.
				Beispielantwort:
				<pre class="prettyprint"><code class="language-javascriptn">{ "time": "2016-05-11T14:59:54.375Z"}</code></pre>

				<div class="solution">
					<pre class="prettyprint"><code class="language-javascript"><!--
-->function getTime(onTimeAvailable, onTimeError) {
    if (typeof(onTimeAvailable) !== 'function') {
        throw "'onTimeAvaiable' must be a function";
    }
    if (typeof(onTimeError) !== 'function') {
        throw "'onTimeError' must be a function";
    }

    $.getJSON( "/time")
	.done(function(data){
		onTimeAvailable(data['time']);
	})
	.fail(onTimeError);
}<!--
					--></code></pre>
				</div>
			</li>
			<li>Schauen Sie sich nochmals den nativen XHR-Code der ersten Aufgabe an. Was müssten sie ändern, um mit
			der JSON statt der Plain-Text Antwort zu arbeiten?

				<div class="solution">
					<pre class="prettyprint"><code class="language-javascript"><!--
-->var client = new XMLHttpRequest();
client.onreadystatechange = function () {
	if (client.readyState === 4) {
		if (client.status === 200) {
			onTimeAvailable(<strong class="important-code">JSON.parse(client.responseText)['time']</strong>);
		}
		else {
			onTimeError(client);
		}
	}
};

client.onerror = onTimeError;
client.open('GET', '/time', true);
<strong class="important-code">client.setRequestHeader('Accept','application/json');</strong>
client.send();<!--
					--></code></pre>
				</div>
			</li>
		</ol>
	</body>
</html>
{{#each books}}
<tr>
	<td>{{title}}</td>
	<td>{{genre}}</td>
	<td>{{price}}</td>
</tr>
{{/each}}